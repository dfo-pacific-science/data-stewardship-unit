---
title: "DFO Salmon Data Standards"
subtitle: "Controlled Vocabulary & Thesauri"
freeze: false
format:
  html:
    toc: true
---

The Data Stewardship Unit (DSU) has created the **DFO Salmon Data Controlled Vocabulary**—a standardized, community-curated list of key terms and definitions related to salmon data collection, analysis, and policy within Fisheries and Oceans Canada (DFO) Pacific Region.

The vocabulary tables below consolidate definitions from the DFO Salmon Ontology, regulatory documents, scientific literature, internal guidelines, and other sources into organized, searchable references designed to improve semantic clarity across DFO Pacific.

::: {.callout-note}
**Missing term or definition change?** Open an issue at <https://github.com/dfo-pacific-science/dfo-salmon-ontology/issues> and include: the term name (or new term request), the definition you propose, the source citation/URL, any synonym, and—if applicable—the desired hierarchy placement. For relationship fixes, state the current relationship and the change you want. Prefer GitHub; if needed, email FADSDataStewardship-GestiondesdonneesSFDA@dfo-mpo.gc.ca (may be slower).
:::


```{r}
#| echo: false
#| warning: false
#| results: 'asis'
library(jsonlite)
library(htmltools)
library(tools)

# Load yaml package for reading themes.yml
if (!requireNamespace("yaml", quietly = TRUE)) {
  stop("Package 'yaml' is required. Please install it with: install.packages('yaml')")
}
library(yaml)

# Get project root directory
project_root <- if (Sys.getenv("QUARTO_PROJECT_DIR") != "") {
  Sys.getenv("QUARTO_PROJECT_DIR")
} else {
  # Find _quarto.yml by walking up directory tree
  current <- getwd()
  while (current != dirname(current)) {
    if (file.exists(file.path(current, "_quarto.yml"))) {
      break
    }
    current <- dirname(current)
  }
  current
}

# Load helper functions
helpers_path <- file.path(project_root, "reference_info/ontology/_partials/helpers.R")
source(helpers_path)

# Discover themes from config or term-table metadata
load_themes <- function(project_root, include_desc = FALSE) {
  # Prefer the authoritative ontology config in the sibling dfo-salmon-ontology repo
  themes_yml_candidates <- c(
    file.path(project_root, "..", "dfo-salmon-ontology", "scripts", "config", "themes.yml"),
    file.path(project_root, "data/ontology/scripts/config/themes.yml")
  )
  themes_yml_path <- themes_yml_candidates[file.exists(themes_yml_candidates)][1]
  term_tables_dir <- file.path(project_root, "data/ontology/release/artifacts/term-tables")

  # 1) Prefer themes.yml if present and valid
  if (!is.na(themes_yml_path) && file.exists(themes_yml_path)) {
  themes_config <- tryCatch({
    read_yaml(themes_yml_path)
  }, error = function(e) {
      warning("Failed to read themes.yml: ", e$message)
      NULL
    })

    if (!is.null(themes_config) && !is.null(themes_config$themes)) {
      return(lapply(themes_config$themes, function(theme) {
        csv_filename <- theme$output_csv %||% paste0(theme$id, ".csv")
        theme_id <- sub("\\.csv$", "", csv_filename)
        list(
          id = theme_id,
          label = theme$label,
          desc = if (include_desc) theme$desc %||% "" else NULL
        )
      }))
    }
  }

  # 2) Discover from .meta.json files beside term tables
  meta_files <- list.files(term_tables_dir, pattern = "\\.meta\\.json$", full.names = TRUE)
  if (length(meta_files) > 0) {
    themes <- lapply(meta_files, function(meta_path) {
      meta <- tryCatch(fromJSON(meta_path), error = function(e) NULL) %||% list()
      theme_id <- sub("\\.meta\\.json$", "", basename(meta_path))
      label <- meta$label %||% meta$theme %||% toTitleCase(gsub("-", " ", theme_id))
      desc <- meta$description %||% ""
      list(
        id = theme_id,
        label = label,
        desc = if (include_desc) desc else NULL
      )
    })

    # Sort themes by label for stable UI
    themes <- themes[order(tolower(sapply(themes, function(t) t$label)))]
    return(themes)
  }

  stop("No themes.yml or meta files found; sync term tables from dfo-salmon-ontology.")
}

# Load themes dynamically
themes <- load_themes(project_root, include_desc = FALSE)

# Load all term tables
all_terms <- list()
for (theme_idx in seq_along(themes)) {
  current_theme <- themes[[theme_idx]]
  current_theme_label <- as.character(current_theme$label)
  current_theme_id <- as.character(current_theme$id)

  csv_path <- file.path(project_root, "data/ontology/release/artifacts/term-tables",
                        paste0(current_theme_id, ".csv"))
  result <- load_dataset(csv_path)
  df <- result$data
  meta <- result$metadata

  if (!is.null(df) && nrow(df) > 0) {
    for (i in seq_len(nrow(df))) {
      row <- df[i, ]
      all_terms[[length(all_terms) + 1]] <- list(
        term_name = as.character(row$term_name %||% ""),
        definition = as.character(row$definition %||% ""),
        definition_source = as.character(row$definition_source %||% ""),
        definition_source_text = as.character(row$definition_source_text %||% ""),
        definition_source_link = as.character(row$definition_source_link %||% ""),
        related_terms = as.character(row$related_terms %||% ""),
        canonical_uri = as.character(row$canonical_uri %||% ""),
        widoco_link = as.character(row$widoco_link %||% ""),
        theme = current_theme_label,
        theme_id = current_theme_id
      )
    }
  }
}

# Calculate statistics
total_terms <- length(all_terms)
terms_by_theme <- table(sapply(all_terms, function(x) x$theme))
terms_with_definitions <- sum(sapply(all_terms, function(x) {
  def <- x$definition %||% ""
  nchar(trimws(def)) > 0 && def != "No definition available"
}))
terms_with_sources <- sum(sapply(all_terms, function(x) {
  source_text <- x$definition_source_text %||% ""
  source_link <- x$definition_source_link %||% ""
  nchar(trimws(source_text)) > 0 || nchar(trimws(source_link)) > 0
}))
terms_with_related <- sum(sapply(all_terms, function(x) {
  related <- x$related_terms %||% ""
  nchar(trimws(related)) > 0
}))

# Create JavaScript searchable index
# Escape JSON properly for embedding in JavaScript
terms_json <- toJSON(all_terms, auto_unbox = TRUE, pretty = TRUE)

theme_counts <- as.list(terms_by_theme[order(terms_by_theme, decreasing = TRUE)])
max_theme_count <- if (length(theme_counts) > 0) max(unlist(theme_counts)) else 1
theme_rows <- paste0(
  vapply(names(theme_counts), function(name) {
    count <- theme_counts[[name]]
    width_pct <- if (max_theme_count > 0) round((count / max_theme_count) * 100) else 0
    sprintf(
      '<div class="theme-bar">
         <div class="theme-bar-label">%s</div>
         <div class="theme-bar-track">
           <div class="theme-bar-fill" style="width:%s%%"></div>
         </div>
         <div class="theme-bar-count">%s</div>
       </div>',
      htmlEscape(name), width_pct, count
    )
  }, FUN.VALUE = character(1)),
  collapse = ""
)

summary_html <- paste0(
  '<div class="summary-strip">',
  '  <div class="summary-line"><strong>Total terms:</strong> ', total_terms,
  ' &nbsp;|&nbsp; <strong>Themes:</strong> ', length(themes), '</div>',
  '  <div class="theme-bars">', theme_rows, '</div>',
  '</div>'
)

search_html_parts <- c(
  '<style>',
  '  #vocab-search-input {',
  '    border: 2px solid #446c8a !important;',
  '    transition: border-color 0.2s, box-shadow 0.2s;',
  '  }',
  '  .search-tip {',
  '    font-size: 0.95rem;',
  '    color: #495057;',
  '    margin: 0 0 0.5rem 0;',
  '  }',
  '  #vocab-search-input:focus {',
  '    outline: none;',
  '    border-color: #2c5282 !important;',
  '    box-shadow: 0 0 0 3px rgba(68, 108, 138, 0.1);',
  '  }',
  '  .search-tip {',
  '    font-size: 0.95rem;',
  '    color: #495057;',
  '    margin: 0 0 0.5rem 0;',
  '  }',
  '  .summary-strip {',
  '    border: 1px solid #e9ecef;',
  '    border-radius: 6px;',
  '    background: #f8f9fa;',
  '    padding: 0.75rem 1rem;',
  '    margin-bottom: 0.75rem;',
  '  }',
  '  .summary-line {',
  '    font-size: 0.95rem;',
  '    color: #495057;',
  '    margin-bottom: 0.5rem;',
  '  }',
  '  .theme-bars {',
  '    display: grid;',
  '    gap: 0.35rem;',
  '  }',
  '  .theme-bar {',
  '    display: grid;',
  '    grid-template-columns: 1fr 3fr auto;',
  '    gap: 0.5rem;',
  '    align-items: center;',
  '    font-size: 0.9rem;',
  '    color: #495057;',
  '  }',
  '  .theme-bar-track {',
  '    background: #f1f3f5;',
  '    border-radius: 4px;',
  '    overflow: hidden;',
  '    height: 8px;',
  '  }',
  '  .theme-bar-fill {',
  '    height: 8px;',
  '    background: #446c8a;',
  '  }',
  '  .theme-bar-count {',
  '    font-size: 0.85rem;',
  '    color: #6c757d;',
  '  }',
  '</style>',
  '<div id="vocab-search-container">',
  summary_html,
  '<h2 style="margin: 0.35rem 0;">Search</h2>',
  '  <div class="search-tip">Search matches across term names, definitions, and related terms. Use multiple words to narrow results (e.g., “reference point harvest”).</div>',
  '  <div style="margin: 0 0 1.25rem 0;">',
  '    <input ',
  '      type="text" ',
  '      id="vocab-search-input" ',
  '      placeholder="Search terms, definitions, or related concepts..." ',
  '      style="width: 100%; padding: 0.75rem; font-size: 1rem; border-radius: 0.25rem;"',
  '      autocomplete="off"',
  '    />',
  '    <div id="search-results-count" style="margin-top: 0.5rem; color: #6c757d; font-size: 0.9rem;"></div>',
  '  </div>',
  '  <div id="vocab-search-results"></div>',
  '</div>',
  '',
  '<script>',
  '(function() {',
  paste0('  const terms = ', terms_json, ';'),
  '  window.allTermsData = terms;',
  '  const searchInput = document.getElementById("vocab-search-input");',
  '  const resultsContainer = document.getElementById("vocab-search-results");',
  '  const countContainer = document.getElementById("search-results-count");',
  '  ',
  '  function normalizeText(text) {',
  '    return (text || "").toLowerCase().trim();',
  '  }',
  '  ',
  '  function searchTerms(query) {',
  '    if (!query) {',
  '      resultsContainer.innerHTML = "";',
  '      countContainer.textContent = "";',
  '      return;',
  '    }',
  '    ',
  '    const normalizedQuery = normalizeText(query);',
  '    const queryWords = normalizedQuery.split(/\\s+/).filter(w => w.length > 0);',
  '    ',
  '    const matches = terms.filter(term => {',
  '      const searchableText = normalizeText(',
  '        term.term_name + " " + ',
  '        term.definition + " " + ',
  '        term.related_terms',
  '      );',
  '      ',
  '      return queryWords.every(word => searchableText.includes(word));',
  '    });',
  '    ',
  '    const countText = matches.length === 0 ',
  '      ? "No results found" ',
  '      : "Found " + matches.length + " term" + (matches.length !== 1 ? "s" : "");',
  '    countContainer.textContent = countText;',
  '    ',
  '    if (matches.length === 0) {',
  '      resultsContainer.innerHTML = "<p style=\\"color: #6c757d; padding: 1rem;\\">No matching terms found. Try different keywords or browse by theme below.</p>";',
  '      return;',
  '    }',
  '    ',
  '    let html = "<div style=\\"display: grid; gap: 1rem;\\">";',
  '    matches.forEach(term => {',
  '      const uri = term.canonical_uri || "";',
  '      const sourceText = term.definition_source_text || "";',
  '      const sourceLink = term.definition_source_link || "";',
  '      let sourceHtml = "";',
  '      if (sourceText) {',
  '        sourceHtml = sourceText;',
  '        if (sourceLink) {',
  '          sourceHtml += "<br><a href=\\"" + sourceLink + "\\" target=\\"_blank\\" rel=\\"noopener\\" style=\\"font-size: 0.9rem; color: #446c8a;\\">Source</a>";',
  '        }',
  '      } else if (sourceLink) {',
  '        sourceHtml = "<a href=\\"" + sourceLink + "\\" target=\\"_blank\\" rel=\\"noopener\\" style=\\"font-size: 0.9rem; color: #446c8a;\\">" + sourceLink + "</a>";',
  '      }',
  '      ',
  '      const themeName = term.theme || "";',
  '      const termName = term.term_name || "";',
  '      const definition = term.definition || "No definition available";',
  '      ',
  '      html += "<div style=\\"border: 1px solid #dee2e6; border-radius: 0.25rem; padding: 1rem; background: white;\\">";',
  '      html += "<div style=\\"display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;\\">";',
  '      html += "<h3 style=\\"margin: 0; font-size: 1.1rem; color: #446c8a;\\">" + termName + "</h3>";',
  '      html += "<span style=\\"font-size: 0.85rem; color: #6c757d; background: #f8f9fa; padding: 0.25rem 0.5rem; border-radius: 0.25rem;\\">" + themeName + "</span>";',
  '      html += "</div>";',
  '      html += "<p style=\\"margin: 0.5rem 0; color: #495057;\\">" + definition + "</p>";',
  '      if (sourceHtml) {',
  '        html += "<p style=\\"margin: 0.5rem 0; font-size: 0.9rem; color: #6c757d; font-style: italic;\\">Source: " + sourceHtml + "</p>";',
  '      }',
  '      html += "<div style=\\"display: flex; gap: 1rem; margin-top: 0.75rem; font-size: 0.9rem;\\">";',
  '      html += "<div style=\\"flex: 1;\\"><strong>URI:</strong> <code style=\\"font-size: 0.85rem;\\">" + uri + "</code>";',
  '      html += "<button type=\\"button\\" class=\\"copy-uri-btn\\" data-uri=\\"" + uri + "\\" style=\\"margin-left: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.85rem; border: 1px solid #dee2e6; background: white; border-radius: 0.25rem; cursor: pointer;\\">Copy</button></div>";',
  '      html += "</div></div>";',
  '    });',
  '    html += "</div>";',
  '    resultsContainer.innerHTML = html;',
  '    ',
  '    document.querySelectorAll(".copy-uri-btn").forEach(btn => {',
  '      btn.addEventListener("click", function() {',
  '        const uri = this.getAttribute("data-uri");',
  '        navigator.clipboard.writeText(uri).then(() => {',
  '          const original = this.textContent;',
  '          this.textContent = "Copied!";',
  '          setTimeout(() => {',
  '            this.textContent = original;',
  '          }, 1500);',
  '        });',
  '      });',
  '    });',
  '  }',
  '  ',
  '  let searchTimeout;',
  '  searchInput.addEventListener("input", function() {',
  '    clearTimeout(searchTimeout);',
  '    const query = this.value;',
  '    searchTimeout = setTimeout(() => searchTerms(query), 300);',
  '  });',
  '  ',
  '  resultsContainer.innerHTML = "";',
  '})();',
  '</script>'
)

search_html <- paste(search_html_parts, collapse = "\n")
knitr::raw_html(search_html)
```

## Browse by Theme

```{r}
#| echo: false
#| warning: false
library(htmltools)
library(knitr)
library(htmlwidgets)

# Get project root directory (reuse from previous chunk if available, otherwise find it)
if (!exists("project_root")) {
  project_root <- if (Sys.getenv("QUARTO_PROJECT_DIR") != "") {
    Sys.getenv("QUARTO_PROJECT_DIR")
  } else {
    current <- getwd()
    while (current != dirname(current)) {
      if (file.exists(file.path(current, "_quarto.yml"))) {
        break
      }
      current <- dirname(current)
    }
    current
  }
}

# Load required R packages
library(readr)
library(jsonlite)
library(reactable)
library(htmltools)
library(htmlwidgets)
library(knitr)

# Load helper functions (if not already loaded)
if (!exists("load_dataset")) {
  helpers_path <- file.path(project_root, "reference_info/ontology/_partials/helpers.R")
  source(helpers_path)
}

# Load yaml package if not already loaded
if (!requireNamespace("yaml", quietly = TRUE)) {
  stop("Package 'yaml' is required. Please install it with: install.packages('yaml')")
}
if (!exists("yaml")) {
  library(yaml)
}

themes_with_desc <- load_themes(project_root, include_desc = TRUE)

themes <- themes_with_desc

# Store theme data for rendering
theme_data <- list()
for (idx in seq_along(themes)) {
  theme <- themes[[idx]]
  theme_id <- theme$id
  csv_path <- file.path(project_root, "data/ontology/release/artifacts/term-tables",
                        paste0(theme_id, ".csv"))
  result <- load_dataset(csv_path)
  theme_data[[theme_id]] <- list(
    df = result$data,
    meta = result$metadata,
    label = theme$label,
    desc = theme$desc %||% ""
  )
}

# Build accordion sections (one per theme)
accordion_sections <- list()
for (idx in seq_along(themes)) {
  theme <- themes[[idx]]
  theme_id <- theme$id
  theme_info <- theme_data[[theme_id]]
  df <- theme_info$df
  desc <- theme_info$desc %||% ""

  panel_content <- if (is.null(df) || nrow(df) == 0) {
    tags$p("Term table not found. Run the ontology extraction workflow to generate term tables.")
  } else {
    render_table(df, theme_label = theme$label)
  }

  accordion_sections[[idx]] <- tags$section(
    id = paste0("theme-", theme_id),
    class = "theme-accordion-item",
    tags$button(
      class = "theme-accordion-toggle",
      `data-target` = paste0("panel-", theme_id),
      style = "width: 100%; text-align: left; padding: 0.75rem 1rem; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 6px; font-weight: 600; color: #495057; display: flex; justify-content: space-between; align-items: center;",
      tags$span(theme$label),
      tags$span(if (nzchar(desc)) desc else "")
    ),
    tags$div(
    id = paste0("panel-", theme_id),
      class = "theme-accordion-panel",
      style = "display: none; margin-top: 0.35rem;",
    panel_content
    )
  )
}

tabs_container <- tags$div(
  class = "theme-accordion-container",
  tags$p(style = "margin: 0.25rem 0 0.5rem 0; color: #495057;",
         "Click a category to expand and view its terms."),
  accordion_sections,
  tags$style(HTML('
    .theme-accordion-container {
      margin-top: 1rem;
      display: grid;
      gap: 0.75rem;
    }
    .theme-accordion-item {
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 0.5rem;
      background: #fff;
    }
    .theme-accordion-toggle {
      cursor: pointer;
    }
    .theme-accordion-toggle.open {
      background: #fff;
      border-color: #ced4da;
    }
    .theme-accordion-panel {
      padding: 0.5rem 0.25rem 0.25rem 0.25rem;
    }
  ')),
  tags$script(HTML("
    (function() {
      const toggles = document.querySelectorAll('.theme-accordion-toggle');
      toggles.forEach(btn => {
        btn.addEventListener('click', function() {
          const targetId = this.getAttribute('data-target');
          const panel = document.getElementById(targetId);
          if (!panel) return;

          const isOpen = panel.style.display === 'block';
          document.querySelectorAll('.theme-accordion-panel').forEach(p => { p.style.display = 'none'; });
          document.querySelectorAll('.theme-accordion-toggle').forEach(b => { b.classList.remove('open'); });

          if (!isOpen) {
            panel.style.display = 'block';
            this.classList.add('open');
          }
        });
      });

    })();
  "))
)

# Output the complete structure
tabs_container
```

## About the Vocabulary Structure

Under the hood, the vocabulary is formatted in SKOS (Simple Knowledge Organization System), a W3C-recommended framework for representing controlled vocabularies and thesauri. By modeling terms and their relationships (broader, narrower, related), SKOS makes it easy to:

- Maintain consistent labels, definitions, and concept hierarchies.
- Share and integrate the vocabulary with other systems that understand RDF.

The vocabulary is intended to be a living document that evolves with the needs of the community. It is maintained by the Data Stewardship Unit (DSU) within the Fisheries and Assessment Data Section (FADS) in the Pacific Region of Fisheries and Oceans Canada (DFO).

The vocabulary is more than a simple glossary: it is a formally structured controlled vocabulary that uses the W3C-endorsed Simple Knowledge Organization System (SKOS), enabling machine-readable formats for integration into data systems, APIs, and web applications. For a deep-dive on the how and why of controlled vocabularies, see our guide: [Support Controlled Vocabularies](https://dfo-pacific-science.github.io/data-stewardship-unit/tutorials/support_controlled_vocabs.html).

## Contributing

File a GitHub Issue at https://github.com/dfo-pacific-science/data-stewardship-unit/issues

Or contact the Data Stewardship Unit.
