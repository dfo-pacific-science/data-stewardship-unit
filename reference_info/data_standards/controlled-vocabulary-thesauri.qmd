---
title: "DFO Salmon Data Standards"
subtitle: "Controlled Vocabulary & Thesauri"
freeze: auto
format:
  html:
    toc: true
    css: ../../styles/custom.css
---

The Data Stewardship Unit (DSU) has created the **GC DFO Salmon Data Controlled Vocabulary**—a standardized, community-curated list of key terms and definitions related to salmon data collection, analysis, and policy within Fisheries and Oceans Canada (DFO) Pacific Region.

The vocabulary tables below consolidate definitions from the DFO Salmon Ontology, regulatory documents, scientific literature, internal guidelines, and other sources into organized, searchable references designed to improve semantic clarity across DFO Pacific.

::: {.callout-note}
**Missing term or definition change?** Open a ticket in the <a href="https://github.com/dfo-pacific-science/dfo-salmon-ontology/issues" target="_blank">GCDFO Salmon Ontology Tracker</a> and include: the term name (or new term request), the definition you propose, the source citation/URL, any synonym, and the desired hierarchy placement (if applicable). For relationship fixes, state the current relationship and the change you want. GitHub is preferred; if needed, email the <a href="mailto:FADSDataStewardship-GestiondesdonneesSFDA@dfo-mpo.gc.ca">FADS Data Stewardship Unit</a> (note: response time may be longer). See our <a href="https://github.com/dfo-pacific-science/dfo-salmon-ontology/blob/main/CONTRIBUTING.md" target="_blank">Contributing Guidelines</a> for more details.
:::


```{r}
#| echo: false
#| warning: false
#| results: 'asis'
library(jsonlite)
library(htmltools)
library(tools)

# Load yaml package for reading themes.yml
if (!requireNamespace("yaml", quietly = TRUE)) {
  stop("Package 'yaml' is required. Please install it with: install.packages('yaml')")
}
library(yaml)

# Get project root directory
project_root <- if (Sys.getenv("QUARTO_PROJECT_DIR") != "") {
  Sys.getenv("QUARTO_PROJECT_DIR")
} else {
  # Find _quarto.yml by walking up directory tree
  current <- getwd()
  while (current != dirname(current)) {
    if (file.exists(file.path(current, "_quarto.yml"))) {
      break
    }
    current <- dirname(current)
  }
  current
}

# Load helper functions
helpers_path <- file.path(project_root, "reference_info/ontology/_partials/helpers.R")
source(helpers_path)

# Discover themes from config or term-table metadata
load_themes <- function(project_root, include_desc = FALSE) {
  # Prefer the authoritative ontology config in the sibling dfo-salmon-ontology repo
  themes_yml_candidates <- c(
    file.path(project_root, "..", "dfo-salmon-ontology", "scripts", "config", "themes.yml"),
    file.path(project_root, "data/ontology/scripts/config/themes.yml")
  )
  themes_yml_path <- themes_yml_candidates[file.exists(themes_yml_candidates)][1]
  term_tables_dir <- file.path(project_root, "data/ontology/release/artifacts/term-tables")

  # 1) Prefer themes.yml if present and valid
  if (!is.na(themes_yml_path) && file.exists(themes_yml_path)) {
  themes_config <- tryCatch({
    read_yaml(themes_yml_path)
  }, error = function(e) {
      warning("Failed to read themes.yml: ", e$message)
      NULL
    })

    if (!is.null(themes_config) && !is.null(themes_config$themes)) {
      return(lapply(themes_config$themes, function(theme) {
        csv_filename <- theme$output_csv %||% paste0(theme$id, ".csv")
        theme_id <- sub("\\.csv$", "", csv_filename)
        list(
          id = theme_id,
          label = theme$label,
          desc = if (include_desc) theme$desc %||% "" else NULL
        )
      }))
    }
  }

  # 2) Discover from .meta.json files beside term tables
  meta_files <- list.files(term_tables_dir, pattern = "\\.meta\\.json$", full.names = TRUE)
  if (length(meta_files) > 0) {
    themes <- lapply(meta_files, function(meta_path) {
      meta <- tryCatch(fromJSON(meta_path), error = function(e) NULL) %||% list()
      theme_id <- sub("\\.meta\\.json$", "", basename(meta_path))
      label <- meta$label %||% meta$theme %||% toTitleCase(gsub("-", " ", theme_id))
      desc <- meta$description %||% ""
      list(
        id = theme_id,
        label = label,
        desc = if (include_desc) desc else NULL
      )
    })

    # Sort themes by label for stable UI
    themes <- themes[order(tolower(sapply(themes, function(t) t$label)))]
    return(themes)
  }

  stop("No themes.yml or meta files found; sync term tables from dfo-salmon-ontology.")
}

# Load themes dynamically (with descriptions to reuse downstream)
themes <- load_themes(project_root, include_desc = TRUE)

# Load all term tables
all_terms <- list()
for (theme_idx in seq_along(themes)) {
  current_theme <- themes[[theme_idx]]
  current_theme_label <- as.character(current_theme$label)
  current_theme_id <- as.character(current_theme$id)

  csv_path <- file.path(project_root, "data/ontology/release/artifacts/term-tables",
                        paste0(current_theme_id, ".csv"))
  result <- load_dataset(csv_path)
  df <- result$data
  meta <- result$metadata

  if (!is.null(df) && nrow(df) > 0) {
    for (i in seq_len(nrow(df))) {
      row <- df[i, ]
      all_terms[[length(all_terms) + 1]] <- list(
        term_name = as.character(row$term_name %||% ""),
        definition = as.character(row$definition %||% ""),
        definition_source = as.character(row$definition_source %||% ""),
        definition_source_text = as.character(row$definition_source_text %||% ""),
        definition_source_link = as.character(row$definition_source_link %||% ""),
        related_terms = as.character(row$related_terms %||% ""),
        canonical_uri = as.character(row$canonical_uri %||% ""),
        widoco_link = as.character(row$widoco_link %||% ""),
        theme = current_theme_label,
        theme_id = current_theme_id
      )
    }
  }
}

# Calculate statistics
total_terms <- length(all_terms)
terms_by_theme <- table(sapply(all_terms, function(x) x$theme))
terms_with_definitions <- sum(sapply(all_terms, function(x) {
  def <- x$definition %||% ""
  nchar(trimws(def)) > 0 && def != "No definition available"
}))
terms_with_sources <- sum(sapply(all_terms, function(x) {
  source_text <- x$definition_source_text %||% ""
  source_link <- x$definition_source_link %||% ""
  nchar(trimws(source_text)) > 0 || nchar(trimws(source_link)) > 0
}))
terms_with_related <- sum(sapply(all_terms, function(x) {
  related <- x$related_terms %||% ""
  nchar(trimws(related)) > 0
}))

# Create JavaScript searchable index
# Escape JSON properly for embedding in JavaScript
terms_json <- toJSON(all_terms, auto_unbox = TRUE, pretty = TRUE)

theme_counts <- as.list(terms_by_theme[order(terms_by_theme, decreasing = TRUE)])
max_theme_count <- if (length(theme_counts) > 0) max(unlist(theme_counts)) else 1
theme_rows <- paste0(
  vapply(names(theme_counts), function(name) {
    count <- theme_counts[[name]]
    width_pct <- if (max_theme_count > 0) round((count / max_theme_count) * 100) else 0
    sprintf(
      '<div class="theme-bar">
         <div class="theme-bar-label">%s</div>
         <div class="theme-bar-track">
           <div class="theme-bar-fill" style="width:%s%%"></div>
         </div>
         <div class="theme-bar-count">%s</div>
       </div>',
      htmlEscape(name), width_pct, count
    )
  }, FUN.VALUE = character(1)),
  collapse = ""
)

summary_html <- paste0(
  '<div class="summary-strip">',
  '  <div class="summary-line"><strong>Total terms:</strong> ', total_terms,
  ' &nbsp;|&nbsp; <strong>Themes:</strong> ', length(themes), '</div>',
  '  <div class="theme-bars">', theme_rows, '</div>',
  '</div>'
)

search_html_parts <- c(
  '<div id="vocab-search-container">',
  summary_html,
  '<h2 style="margin: 0.35rem 0;">Search</h2>',
  '  <div class="search-tip">Search matches across term names, definitions, and related terms. Use multiple words to narrow results (e.g., “reference point harvest”).</div>',
  '  <div style="margin: 0 0 1.25rem 0;">',
  '    <input ',
  '      type="text" ',
  '      id="vocab-search-input" ',
  '      placeholder="Search terms, definitions, or related concepts..." ',
  '      style="width: 100%; padding: 0.75rem; font-size: 1rem; border-radius: 0.25rem;"',
  '      autocomplete="off"',
  '    />',
  '    <div id="search-results-count" style="margin-top: 0.5rem; color: #6c757d; font-size: 0.9rem;"></div>',
  '    <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.5rem;">',
  '      <button type="button" id="export-visible-csv" style="padding:0.35rem 0.65rem; border:1px solid #dee2e6; background:#f8f9fa; border-radius:4px; cursor:pointer;">Export visible terms (CSV)</button>',
  '      <button type="button" id="export-visible-json" style="padding:0.35rem 0.65rem; border:1px solid #dee2e6; background:#f8f9fa; border-radius:4px; cursor:pointer;">Export visible terms (JSON)</button>',
  '    </div>',
  '  </div>',
  '  <div id="vocab-search-results"></div>',
  '</div>',
  '',
  '<script>',
  '(function() {',
  paste0('  const terms = ', terms_json, ';'),
  '  window.allTermsData = terms;',
  '  const searchInput = document.getElementById("vocab-search-input");',
  '  const resultsContainer = document.getElementById("vocab-search-results");',
  '  const countContainer = document.getElementById("search-results-count");',
  '  const exportCsvBtn = document.getElementById("export-visible-csv");',
  '  const exportJsonBtn = document.getElementById("export-visible-json");',
  '  ',
  '  function normalizeText(text) {',
  '    return (text || "").toLowerCase().trim();',
  '  }',
  '  ',
  '  function buildMatches(query) {',
  '    const normalizedQuery = normalizeText(query);',
  '    if (!normalizedQuery) return terms;',
  '    const queryWords = normalizedQuery.split(/\\s+/).filter(w => w.length > 0);',
  '    return terms.filter(term => {',
  '      const searchableText = normalizeText(',
  '        term.term_name + " " + ',
  '        term.definition + " " + ',
  '        term.related_terms',
  '      );',
  '      return queryWords.every(word => searchableText.includes(word));',
  '    });',
  '  }',
  '  ',
  '  function toCsv(rows) {',
  '    const headers = ["term_name","theme","definition","definition_source_text","definition_source_link","related_terms","canonical_uri","widoco_link"];',
  '    const escapeCell = (v) => {',
  '      const s = (v ?? "").toString();',
  '      if (/[",\\n]/.test(s)) return "\\"" + s.replace(/\\"/g, "\\"\\"") + "\\"";',
  '      return s;',
  '    };',
  '    const body = rows.map(row => headers.map(h => escapeCell(row[h])).join(","));',
  '    return [headers.join(",")].concat(body).join("\\n");',
  '  }',
  '  ',
  '  function downloadBlob(content, fileName, mimeType) {',
  '    const blob = new Blob([content], { type: mimeType });',
  '    const url = URL.createObjectURL(blob);',
  '    const a = document.createElement("a");',
  '    a.href = url;',
  '    a.download = fileName;',
  '    document.body.appendChild(a);',
  '    a.click();',
  '    a.remove();',
  '    URL.revokeObjectURL(url);',
  '  }',
  '  ',
  '  function searchTerms(query) {',
  '    const normalizedQuery = normalizeText(query);',
  '    if (!normalizedQuery) {',
  '      resultsContainer.innerHTML = "";',
  '      countContainer.textContent = "Showing all terms in table below. Type in search to preview matches here.";',
  '      return;',
  '    }',
  '    ',
  '    const matches = buildMatches(normalizedQuery);',
  '    ',
  '    const countText = matches.length === 0 ',
  '      ? "No results found" ',
  '      : "Found " + matches.length + " term" + (matches.length !== 1 ? "s" : "");',
  '    countContainer.textContent = countText;',
  '    ',
  '    if (matches.length === 0) {',
  '      resultsContainer.innerHTML = "<p style=\\"color: #6c757d; padding: 1rem;\\">No matching terms found. Try different keywords or browse by theme below.</p>";',
  '      return;',
  '    }',
  '    ',
  '    let html = "<div style=\\"display: grid; gap: 1rem;\\">";',
  '    matches.forEach(term => {',
  '      const uri = term.canonical_uri || "";',
  '      const sourceText = term.definition_source_text || "";',
  '      const sourceLink = term.definition_source_link || "";',
  '      let sourceHtml = "";',
  '      if (sourceText) {',
  '        sourceHtml = sourceText;',
  '        if (sourceLink) {',
  '          sourceHtml += "<br><a href=\\"" + sourceLink + "\\" target=\\"_blank\\" rel=\\"noopener\\" style=\\"font-size: 0.9rem; color: #446c8a;\\">Source</a>";',
  '        }',
  '      } else if (sourceLink) {',
  '        sourceHtml = "<a href=\\"" + sourceLink + "\\" target=\\"_blank\\" rel=\\"noopener\\" style=\\"font-size: 0.9rem; color: #446c8a;\\">" + sourceLink + "</a>";',
  '      }',
  '      ',
  '      const themeName = term.theme || "";',
  '      const termName = term.term_name || "";',
  '      const definition = term.definition || "No definition available";',
  '      ',
  '      html += "<div style=\\"border: 1px solid #dee2e6; border-radius: 0.25rem; padding: 1rem; background: white;\\">";',
  '      html += "<div style=\\"display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;\\">";',
  '      html += "<h3 style=\\"margin: 0; font-size: 1.1rem; color: #446c8a;\\">" + termName + "</h3>";',
  '      html += "<span style=\\"font-size: 0.85rem; color: #6c757d; background: #f8f9fa; padding: 0.25rem 0.5rem; border-radius: 0.25rem;\\">" + themeName + "</span>";',
  '      html += "</div>";',
  '      html += "<p style=\\"margin: 0.5rem 0; color: #495057;\\">" + definition + "</p>";',
  '      if (sourceHtml) {',
  '        html += "<p style=\\"margin: 0.5rem 0; font-size: 0.9rem; color: #6c757d; font-style: italic;\\">Source: " + sourceHtml + "</p>";',
  '      }',
  '      html += "<div style=\\"display: flex; gap: 1rem; margin-top: 0.75rem; font-size: 0.9rem;\\">";',
  '      html += "<div style=\\"flex: 1;\\"><strong>URI:</strong> <code style=\\"font-size: 0.85rem;\\">" + uri + "</code>";',
  '      html += "<button type=\\"button\\" class=\\"copy-uri-btn\\" data-uri=\\"" + uri + "\\" style=\\"margin-left: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.85rem; border: 1px solid #dee2e6; background: white; border-radius: 0.25rem; cursor: pointer;\\">Copy</button></div>";',
  '      html += "</div></div>";',
  '    });',
  '    html += "</div>";',
  '    resultsContainer.innerHTML = html;',
  '    ',
  '    document.querySelectorAll(".copy-uri-btn").forEach(btn => {',
  '      btn.addEventListener("click", function() {',
  '        const uri = this.getAttribute("data-uri");',
  '        navigator.clipboard.writeText(uri).then(() => {',
  '          const original = this.textContent;',
  '          this.textContent = "Copied!";',
  '          setTimeout(() => {',
  '            this.textContent = original;',
  '          }, 1500);',
  '        });',
  '      });',
  '    });',
  '  }',
  '  ',
  '  if (exportCsvBtn) {',
  '    exportCsvBtn.addEventListener("click", function() {',
  '      const matches = buildMatches(searchInput ? searchInput.value : "");',
  '      const csv = toCsv(matches);',
  '      downloadBlob(csv, "salmon-vocabulary-export.csv", "text/csv;charset=utf-8");',
  '    });',
  '  }',
  '  ',
  '  if (exportJsonBtn) {',
  '    exportJsonBtn.addEventListener("click", function() {',
  '      const matches = buildMatches(searchInput ? searchInput.value : "");',
  '      downloadBlob(JSON.stringify(matches, null, 2), "salmon-vocabulary-export.json", "application/json;charset=utf-8");',
  '    });',
  '  }',
  '  ',
  '  function applyRelatedTermLink(link) {',
  '    if (!link || !searchInput) return;',
  '    const termName = (link.getAttribute("data-term-name") || "").trim();',
  '    if (!termName) return;',
  '    searchInput.value = termName;',
  '    searchTerms(termName);',
  '    searchInput.focus();',
  '    searchInput.scrollIntoView({ behavior: "smooth", block: "center" });',
  '  }',
  '  ',
  '  window.handleRelatedTermClick = function(event, el) {',
  '    if (event && event.preventDefault) event.preventDefault();',
  '    if (event && event.stopPropagation) event.stopPropagation();',
  '    applyRelatedTermLink(el);',
  '    return false;',
  '  };',
  '  ',
  '  document.addEventListener("click", function(event) {',
  '    const link = event.target.closest(".related-term-link");',
  '    if (!link) return;',
  '    event.preventDefault();',
  '    applyRelatedTermLink(link);',
  '  });',
  '  ',
  '  let searchTimeout;',
  '  searchInput.addEventListener("input", function() {',
  '    clearTimeout(searchTimeout);',
  '    const query = this.value;',
  '    searchTimeout = setTimeout(() => searchTerms(query), 300);',
  '  });',
  '  ',
  '  resultsContainer.innerHTML = "";',
  '})();',
  '</script>'
)

search_html <- paste(search_html_parts, collapse = "\n")

# Share loaded themes and terms for reuse in the table chunk
themes_with_desc <- themes
if (length(all_terms) > 0) {
  shared_terms_df <- do.call(rbind, lapply(all_terms, function(x) {
    as.data.frame(x, stringsAsFactors = FALSE)
  }))
}
# free memory from raw list now that we have a data frame copy
rm(all_terms)

knitr::raw_html(search_html)
```

## Browse All Terms

```{r}
#| echo: false
#| warning: false
library(htmltools)
library(knitr)
library(htmlwidgets)

# Get project root directory (reuse from previous chunk if available, otherwise find it)
if (!exists("project_root")) {
  project_root <- if (Sys.getenv("QUARTO_PROJECT_DIR") != "") {
    Sys.getenv("QUARTO_PROJECT_DIR")
  } else {
    current <- getwd()
    while (current != dirname(current)) {
      if (file.exists(file.path(current, "_quarto.yml"))) {
        break
      }
      current <- dirname(current)
    }
    current
  }
}

# Load required R packages
library(readr)
library(jsonlite)
library(reactable)
library(htmltools)
library(htmlwidgets)
library(knitr)

# Load helper functions (if not already loaded)
if (!exists("load_dataset")) {
  helpers_path <- file.path(project_root, "reference_info/ontology/_partials/helpers.R")
  source(helpers_path)
}

# Load yaml package if not already loaded
if (!requireNamespace("yaml", quietly = TRUE)) {
  stop("Package 'yaml' is required. Please install it with: install.packages('yaml')")
}
if (!exists("yaml")) {
  library(yaml)
}

# Load themes and combine all term tables (reuse preloaded data when available)
if (!exists("themes_with_desc")) {
  themes_with_desc <- load_themes(project_root, include_desc = TRUE)
}

terms_df <- NULL
if (exists("shared_terms_df")) {
  terms_df <- shared_terms_df
} else {
  combined_terms <- list()
  for (theme in themes_with_desc) {
    theme_id <- theme$id
    csv_path <- file.path(
      project_root,
      "data/ontology/release/artifacts/term-tables",
      paste0(theme_id, ".csv")
    )
    result <- load_dataset(csv_path)
    df <- result$data

    if (!is.null(df) && nrow(df) > 0) {
      df$theme <- theme$label
      df$theme_id <- theme_id
      combined_terms[[length(combined_terms) + 1]] <- df
    }
  }

  if (length(combined_terms) > 0) {
    terms_df <- do.call(rbind, combined_terms)
  }
}

if (is.null(terms_df)) {
  tags$p("No term tables found. Run the ontology extraction workflow to generate term tables.")
} else {

  # Ensure required columns exist
  required_cols <- c(
    "theme", "theme_id", "term_name", "definition", "definition_source",
    "related_terms", "canonical_uri", "widoco_link",
    "definition_source_text", "definition_source_link"
  )
  for (col in required_cols) {
    if (!col %in% names(terms_df)) {
      terms_df[[col]] <- ""
    }
  }
  terms_df[is.na(terms_df)] <- ""
  # Normalize types to avoid factor coercion in reactable serialization
  terms_df[] <- lapply(terms_df, function(col) {
    if (is.factor(col)) return(as.character(col))
    return(col)
  })
  # Deduplicate by canonical_uri when available, otherwise term_name; merge themes per term
  terms_df$dedupe_key <- ifelse(
    !is.na(terms_df$canonical_uri) & terms_df$canonical_uri != "",
    terms_df$canonical_uri,
    terms_df$term_name
  )
  grouped <- split(seq_len(nrow(terms_df)), terms_df$dedupe_key)
  terms_df <- do.call(rbind, lapply(grouped, function(idx) {
    rows <- terms_df[idx, , drop = FALSE]
    primary <- rows[1, , drop = FALSE]
    theme_labels <- unique(rows$theme)
    primary$theme <- paste(theme_labels, collapse = " · ")
    primary$theme_filter <- paste(theme_labels, collapse = "||")
    primary
  }))
  terms_df$dedupe_key <- NULL
  # Sort by term name for consistent ordering across filters
  terms_df <- terms_df[order(tolower(terms_df$term_name)), ]

  # Theme choices for the filter UI
  theme_choices <- vapply(
    themes_with_desc,
    function(t) t$label,
    FUN.VALUE = character(1)
  )

  # Custom column definitions (reuse logic from helpers)
  theme_filter_method <- JS("
    function(rows, columnId, filterValue) {
      if (filterValue === '__none__') return [];
      if (!filterValue || filterValue.length === 0) return rows;
      const normalizedFilter = (filterValue || '')
        .toString()
        .split('||')
        .map(function(v) { return (v || '').trim().toLowerCase(); })
        .filter(Boolean);
      if (normalizedFilter.length === 0) return rows;
      return rows.filter(function(row) {
        const value = (row.values['theme_filter'] || '').toString().trim().toLowerCase();
        const valueParts = value.split('||').map(function(v){ return v.trim(); });
        return valueParts.some(function(v) { return normalizedFilter.includes(v); });
      });
    }
  ")

  term_table <- reactable(
    terms_df,
    columns = list(
      theme = colDef(
        name = "Theme",
        minWidth = 140,
        filterable = TRUE,
        filterMethod = theme_filter_method
      ),
      term_name = colDef(
        name = "Term Name",
        minWidth = 140,
        resizable = TRUE
      ),
      definition = colDef(
        name = "Definition",
        minWidth = 320,
        resizable = TRUE
      ),
      definition_source = colDef(
        name = "Definition Source",
        minWidth = 200,
        resizable = TRUE,
        html = TRUE,
        cell = function(value, index) {
          row <- terms_df[index, ]

          clean_value <- function(val) {
            if (is.null(val) || is.na(val) || val == "nan" || val == "none" || val == "") {
              return("")
            }
            return(as.character(val))
          }

          is_url_iri <- function(val) {
            val <- clean_value(val)
            if (val == "") return(FALSE)
            return(startsWith(val, "http://") || startsWith(val, "https://") ||
                     startsWith(val, "urn:") || startsWith(val, "doi:"))
          }

          make_link <- function(url) {
            HTML(paste0(
              '<a href="', htmlEscape(url, attribute = TRUE),
              '" target="_blank" rel="noopener" style="color: #446c8a;">',
              htmlEscape(url), '</a>'
            ))
          }

          source_link <- clean_value(row$definition_source_link)
          source_text <- clean_value(row$definition_source_text)
          source_raw <- clean_value(row$definition_source)

          if (is_url_iri(source_link)) {
            return(make_link(source_link))
          }
          if (is_url_iri(source_raw)) {
            return(make_link(source_raw))
          }

          if (source_text != "") {
            return(HTML(htmlEscape(source_text)))
          }
          if (source_raw != "") {
            return(HTML(htmlEscape(source_raw)))
          }

          HTML('<span class=\"coming-soon\">Not available</span>')
        }
      ),
      related_terms = colDef(
        name = "Related Terms",
        minWidth = 120,
        resizable = TRUE,
        html = TRUE,
        cell = function(value, index) {
          if (is.null(value) || is.na(value) || value == "" || value == "nan") {
            return(HTML('<span class=\"coming-soon\">None</span>'))
          }

          terms_str <- as.character(value)
          if (terms_str == "") {
            return(HTML('<span class=\"coming-soon\">None</span>'))
          }

          term_parts <- strsplit(terms_str, "; ")[[1]]
          links <- character(0)
          for (term_part in term_parts) {
            term_part <- trimws(term_part)
            if (term_part == "") next

            match <- regmatches(
              term_part,
              regexec("^(.+?)\\s+\\(([^)]+)\\)\\s+\\[(.+?)\\]$", term_part)
            )[[1]]

            if (length(match) >= 4) {
              term_name <- match[2]
              relation <- match[3]
              uri <- match[4]

              link_html <- paste0(
                '<a href=\"#\" ',
                'class=\"related-term-link\" ',
                'data-term-name=\"', htmlEscape(term_name, attribute = TRUE), '\" ',
                'data-term-uri=\"', htmlEscape(uri, attribute = TRUE), '\" ',
                'onclick=\"return window.handleRelatedTermClick && window.handleRelatedTermClick(event, this);\" ',
                'style=\"color: #446c8a; text-decoration: none; margin-right: 0.5rem; display: inline-block;\" ',
                'title=\"', htmlEscape(relation, attribute = TRUE), '\">',
                htmlEscape(term_name),
                '</a>'
              )
              links <- c(links, link_html)
            } else {
              links <- c(links, htmlEscape(term_part))
            }
          }

          if (length(links) == 0) {
            return(HTML('<span class=\"coming-soon\">None</span>'))
          }

          HTML(paste(links, collapse = " "))
        }
      ),
      canonical_uri = colDef(
        name = "Term ID",
        minWidth = 200,
        resizable = TRUE,
        html = TRUE,
        cell = function(value, index) {
          if (is.null(value) || is.na(value) || value == "" || value == "nan") {
            return(HTML('<span class=\"coming-soon\">Unavailable</span>'))
          }
          uri <- htmlEscape(value)
          HTML(paste0(
            '<a href="', htmlEscape(uri, attribute = TRUE),
            '" target="_blank" rel="noopener" style="color: #446c8a; font-family: monospace; font-size: 0.9em;">',
            uri, '</a>'
          ))
        }
      ),
      theme_id = colDef(show = FALSE),
      theme_filter = colDef(show = FALSE),
      widoco_link = colDef(show = FALSE),
      definition_source_text = colDef(show = FALSE),
      definition_source_link = colDef(show = FALSE)
    ),
    defaultColDef = colDef(
      minWidth = 120,
      resizable = TRUE,
      filterable = FALSE
    ),
    resizable = TRUE,
    searchable = TRUE,
    filterable = TRUE,
    defaultSorted = "term_name",
    rownames = FALSE,
    defaultPageSize = 25,
    showPageSizeOptions = TRUE,
    pageSizeOptions = c(10, 25, 50, 100),
    theme = reactableTheme(
      headerStyle = list(
        backgroundColor = "#f8f9fa",
        borderBottom = "1px solid #dee2e6"
      ),
      stripedColor = "#f8f9fa"
    ),
    elementId = "all-terms-table"
  )

  # Build theme filter UI as a dropdown with select/deselect all controls
  filter_controls <- tags$div(
    id = "theme-filter-container",
    style = "margin-bottom: 0.75rem;",
    tags$details(
      id = "theme-filter-dropdown",
      class = "theme-filter-dropdown",
      tags$summary(
        tags$span(id = "theme-filter-summary", "Themes: all selected")
      ),
      tags$div(
        style = "display: flex; flex-direction: column; gap: 0.75rem; padding-top: 0.5rem;",
        tags$div(
          style = "display: flex; gap: 0.5rem; flex-wrap: wrap;",
          tags$button(
            type = "button",
            id = "select-all-themes",
            style = "padding: 0.35rem 0.75rem; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer; color: #495057;"
          , "Select all"),
          tags$button(
            type = "button",
            id = "deselect-all-themes",
            style = "padding: 0.35rem 0.75rem; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer; color: #495057;"
          , "Deselect all")
        ),
        tags$div(
          id = "theme-checkboxes",
          style = "display: flex; flex-direction: column; gap: 0.35rem;",
          lapply(theme_choices, function(label) {
            tags$label(
              style = "display: flex; align-items: center; gap: 0.35rem; font-size: 0.95rem; color: #495057;",
              tags$input(
                type = "checkbox",
                value = label,
                checked = "checked",
                style = "accent-color: #446c8a;"
              ),
              label
            )
          })
        )
      )
    )
  )

  filter_script <- tags$script(HTML("
    (function() {
      const container = document.getElementById('theme-filter-container');
      const tableId = 'all-terms-table';
      if (!container) return;

      const dropdown = document.getElementById('theme-filter-dropdown');
      const summaryLabel = document.getElementById('theme-filter-summary');
      const checkboxes = container.querySelectorAll('#theme-checkboxes input[type=\"checkbox\"]');
      const selectAllBtn = document.getElementById('select-all-themes');
      const deselectAllBtn = document.getElementById('deselect-all-themes');

      function applyThemeFilter() {
        const selectedRaw = Array.from(checkboxes)
          .filter(cb => cb.checked)
          .map(cb => (cb.value || '').toString().trim());

        if (selectedRaw.length === 0) {
          // Empty selection: hide all rows to reflect no themes chosen
          Reactable.setFilter(tableId, 'theme', '__none__');
        } else if (selectedRaw.length === checkboxes.length) {
          // All selected: clear the filter explicitly
          Reactable.setFilter(tableId, 'theme', '');
        } else {
          Reactable.setFilter(tableId, 'theme', selectedRaw.join('||'));
        }

        if (summaryLabel) {
          if (selectedRaw.length === 0) {
            summaryLabel.textContent = 'Themes: none selected';
          } else if (selectedRaw.length === checkboxes.length) {
            summaryLabel.textContent = 'Themes: all selected';
          } else {
            summaryLabel.textContent = 'Themes: ' + selectedRaw.length + ' selected';
          }
        }
      }

      function setAll(checked) {
        checkboxes.forEach(cb => { cb.checked = checked; });
        applyThemeFilter();
      }

      function ensureReadyAndApply(attempts) {
        if (window.Reactable && Reactable.setFilter && Reactable.resetFilter) {
          applyThemeFilter();
          return;
        }
        if (attempts <= 20) {
          setTimeout(function() { ensureReadyAndApply(attempts + 1); }, 150);
        }
      }

      checkboxes.forEach(cb => cb.addEventListener('change', applyThemeFilter));
      if (selectAllBtn) selectAllBtn.addEventListener('click', function(e) { e.preventDefault(); setAll(true); });
      if (deselectAllBtn) deselectAllBtn.addEventListener('click', function(e) { e.preventDefault(); setAll(false); });

      if (summaryLabel) {
        summaryLabel.textContent = 'Themes: all selected';
      }

      if (window.Reactable && Reactable.onReady) {
        Reactable.onReady(tableId, function() { ensureReadyAndApply(0); });
      } else {
        document.addEventListener('DOMContentLoaded', function() { ensureReadyAndApply(0); });
        setTimeout(function() { ensureReadyAndApply(1); }, 300);
      }
    })();
  "))

  browsable(
    tagList(
      filter_controls,
      term_table,
      filter_script
    )
  )
}
```

## About the Vocabulary Structure

Under the hood, the vocabulary is formatted in SKOS (Simple Knowledge Organization System), a W3C-recommended framework for representing controlled vocabularies and thesauri. By modeling terms and their relationships (broader, narrower, related), SKOS makes it easy to:

- Maintain consistent labels, definitions, and concept hierarchies.
- Share and integrate the vocabulary with other systems that understand RDF.

The vocabulary is intended to be a living document that evolves with the needs of the community. It is maintained by the Data Stewardship Unit (DSU) within the Fisheries and Assessment Data Section (FADS) in the Pacific Region of Fisheries and Oceans Canada (DFO).

The vocabulary is more than a simple glossary: it is a formally structured controlled vocabulary that uses the W3C-endorsed Simple Knowledge Organization System (SKOS), enabling machine-readable formats for integration into data systems, APIs, and web applications. For a deep-dive on the how and why of controlled vocabularies, see our guide: [Support Controlled Vocabularies](https://dfo-pacific-science.github.io/data-stewardship-unit/tutorials/support_controlled_vocabs.html).

## Contributing

File a GitHub Issue at https://github.com/dfo-pacific-science/data-stewardship-unit/issues

Or contact the Data Stewardship Unit.
