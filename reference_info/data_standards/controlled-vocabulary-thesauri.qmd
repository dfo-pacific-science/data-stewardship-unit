---
title: "DFO Salmon Data Standards"
subtitle: "Controlled Vocabulary & Thesauri"
freeze: false
format:
  html:
    toc: true
---

The Data Stewardship Unit (DSU) has created the **GC DFO Salmon Data Controlled Vocabulary**—a standardized, community-curated list of key terms and definitions related to salmon data collection, analysis, and policy within Fisheries and Oceans Canada (DFO) Pacific Region.

The vocabulary tables below consolidate definitions from the DFO Salmon Ontology, regulatory documents, scientific literature, internal guidelines, and other sources into organized, searchable references designed to improve semantic clarity across DFO Pacific.

::: {.callout-note}
**Missing term or definition change?** Open a ticket in the [GCDFO Salmon Ontology Tracker](https://github.com/dfo-pacific-science/dfo-salmon-ontology/issues) and include: the term name (or new term request), the definition you propose, the source citation/URL, any synonym, and the desired hierarchy placement (if applicable). For relationship fixes, state the current relationship and the change you want. GitHub is preferred; if needed, email the <a href="mailto:FADSDataStewardship-GestiondesdonneesSFDA@dfo-mpo.gc.ca">FADS Data Stewardship Unit</a> (note: response time may be longer). See our [Contributing Guidelines](https://github.com/dfo-pacific-science/dfo-salmon-ontology/blob/main/CONTRIBUTING.md) for more details. 
:::


```{r}
#| echo: false
#| warning: false
#| results: 'asis'
library(jsonlite)
library(htmltools)
library(tools)

# Load yaml package for reading themes.yml
if (!requireNamespace("yaml", quietly = TRUE)) {
  stop("Package 'yaml' is required. Please install it with: install.packages('yaml')")
}
library(yaml)

# Get project root directory
project_root <- if (Sys.getenv("QUARTO_PROJECT_DIR") != "") {
  Sys.getenv("QUARTO_PROJECT_DIR")
} else {
  # Find _quarto.yml by walking up directory tree
  current <- getwd()
  while (current != dirname(current)) {
    if (file.exists(file.path(current, "_quarto.yml"))) {
      break
    }
    current <- dirname(current)
  }
  current
}

# Load helper functions
helpers_path <- file.path(project_root, "reference_info/ontology/_partials/helpers.R")
source(helpers_path)

# Discover themes from config or term-table metadata
load_themes <- function(project_root, include_desc = FALSE) {
  # Prefer the authoritative ontology config in the sibling dfo-salmon-ontology repo
  themes_yml_candidates <- c(
    file.path(project_root, "..", "dfo-salmon-ontology", "scripts", "config", "themes.yml"),
    file.path(project_root, "data/ontology/scripts/config/themes.yml")
  )
  themes_yml_path <- themes_yml_candidates[file.exists(themes_yml_candidates)][1]
  term_tables_dir <- file.path(project_root, "data/ontology/release/artifacts/term-tables")

  # 1) Prefer themes.yml if present and valid
  if (!is.na(themes_yml_path) && file.exists(themes_yml_path)) {
  themes_config <- tryCatch({
    read_yaml(themes_yml_path)
  }, error = function(e) {
      warning("Failed to read themes.yml: ", e$message)
      NULL
    })

    if (!is.null(themes_config) && !is.null(themes_config$themes)) {
      return(lapply(themes_config$themes, function(theme) {
        csv_filename <- theme$output_csv %||% paste0(theme$id, ".csv")
        theme_id <- sub("\\.csv$", "", csv_filename)
        list(
          id = theme_id,
          label = theme$label,
          desc = if (include_desc) theme$desc %||% "" else NULL
        )
      }))
    }
  }

  # 2) Discover from .meta.json files beside term tables
  meta_files <- list.files(term_tables_dir, pattern = "\\.meta\\.json$", full.names = TRUE)
  if (length(meta_files) > 0) {
    themes <- lapply(meta_files, function(meta_path) {
      meta <- tryCatch(fromJSON(meta_path), error = function(e) NULL) %||% list()
      theme_id <- sub("\\.meta\\.json$", "", basename(meta_path))
      label <- meta$label %||% meta$theme %||% toTitleCase(gsub("-", " ", theme_id))
      desc <- meta$description %||% ""
      list(
        id = theme_id,
        label = label,
        desc = if (include_desc) desc else NULL
      )
    })

    # Sort themes by label for stable UI
    themes <- themes[order(tolower(sapply(themes, function(t) t$label)))]
    return(themes)
  }

  stop("No themes.yml or meta files found; sync term tables from dfo-salmon-ontology.")
}

# Load themes dynamically
themes <- load_themes(project_root, include_desc = FALSE)

# Load all term tables
all_terms <- list()
for (theme_idx in seq_along(themes)) {
  current_theme <- themes[[theme_idx]]
  current_theme_label <- as.character(current_theme$label)
  current_theme_id <- as.character(current_theme$id)

  csv_path <- file.path(project_root, "data/ontology/release/artifacts/term-tables",
                        paste0(current_theme_id, ".csv"))
  result <- load_dataset(csv_path)
  df <- result$data
  meta <- result$metadata

  if (!is.null(df) && nrow(df) > 0) {
    for (i in seq_len(nrow(df))) {
      row <- df[i, ]
      all_terms[[length(all_terms) + 1]] <- list(
        term_name = as.character(row$term_name %||% ""),
        definition = as.character(row$definition %||% ""),
        definition_source = as.character(row$definition_source %||% ""),
        definition_source_text = as.character(row$definition_source_text %||% ""),
        definition_source_link = as.character(row$definition_source_link %||% ""),
        related_terms = as.character(row$related_terms %||% ""),
        canonical_uri = as.character(row$canonical_uri %||% ""),
        widoco_link = as.character(row$widoco_link %||% ""),
        theme = current_theme_label,
        theme_id = current_theme_id
      )
    }
  }
}

# Calculate statistics
total_terms <- length(all_terms)
terms_by_theme <- table(sapply(all_terms, function(x) x$theme))
terms_with_definitions <- sum(sapply(all_terms, function(x) {
  def <- x$definition %||% ""
  nchar(trimws(def)) > 0 && def != "No definition available"
}))
terms_with_sources <- sum(sapply(all_terms, function(x) {
  source_text <- x$definition_source_text %||% ""
  source_link <- x$definition_source_link %||% ""
  nchar(trimws(source_text)) > 0 || nchar(trimws(source_link)) > 0
}))
terms_with_related <- sum(sapply(all_terms, function(x) {
  related <- x$related_terms %||% ""
  nchar(trimws(related)) > 0
}))

# Create JavaScript searchable index
# Escape JSON properly for embedding in JavaScript
terms_json <- toJSON(all_terms, auto_unbox = TRUE, pretty = TRUE)

theme_counts <- as.list(terms_by_theme[order(terms_by_theme, decreasing = TRUE)])
max_theme_count <- if (length(theme_counts) > 0) max(unlist(theme_counts)) else 1
theme_rows <- paste0(
  vapply(names(theme_counts), function(name) {
    count <- theme_counts[[name]]
    width_pct <- if (max_theme_count > 0) round((count / max_theme_count) * 100) else 0
    sprintf(
      '<div class="theme-bar">
         <div class="theme-bar-label">%s</div>
         <div class="theme-bar-track">
           <div class="theme-bar-fill" style="width:%s%%"></div>
         </div>
         <div class="theme-bar-count">%s</div>
       </div>',
      htmlEscape(name), width_pct, count
    )
  }, FUN.VALUE = character(1)),
  collapse = ""
)

summary_html <- paste0(
  '<div class="summary-strip">',
  '  <div class="summary-line"><strong>Total terms:</strong> ', total_terms,
  ' &nbsp;|&nbsp; <strong>Themes:</strong> ', length(themes), '</div>',
  '  <div class="theme-bars">', theme_rows, '</div>',
  '</div>'
)

search_html_parts <- c(
  '<style>',
  '  #vocab-search-input {',
  '    border: 2px solid #446c8a !important;',
  '    transition: border-color 0.2s, box-shadow 0.2s;',
  '  }',
  '  .search-tip {',
  '    font-size: 0.95rem;',
  '    color: #495057;',
  '    margin: 0 0 0.5rem 0;',
  '  }',
  '  #vocab-search-input:focus {',
  '    outline: none;',
  '    border-color: #2c5282 !important;',
  '    box-shadow: 0 0 0 3px rgba(68, 108, 138, 0.1);',
  '  }',
  '  .search-tip {',
  '    font-size: 0.95rem;',
  '    color: #495057;',
  '    margin: 0 0 0.5rem 0;',
  '  }',
  '  .summary-strip {',
  '    border: 1px solid #e9ecef;',
  '    border-radius: 6px;',
  '    background: #f8f9fa;',
  '    padding: 0.75rem 1rem;',
  '    margin-bottom: 0.75rem;',
  '  }',
  '  .summary-line {',
  '    font-size: 0.95rem;',
  '    color: #495057;',
  '    margin-bottom: 0.5rem;',
  '  }',
  '  .theme-bars {',
  '    display: grid;',
  '    gap: 0.35rem;',
  '  }',
  '  .theme-bar {',
  '    display: grid;',
  '    grid-template-columns: 1fr 3fr auto;',
  '    gap: 0.5rem;',
  '    align-items: center;',
  '    font-size: 0.9rem;',
  '    color: #495057;',
  '  }',
  '  .theme-bar-track {',
  '    background: #f1f3f5;',
  '    border-radius: 4px;',
  '    overflow: hidden;',
  '    height: 8px;',
  '  }',
  '  .theme-bar-fill {',
  '    height: 8px;',
  '    background: #446c8a;',
  '  }',
  '  .theme-bar-count {',
  '    font-size: 0.85rem;',
  '    color: #6c757d;',
  '  }',
  '</style>',
  '<div id="vocab-search-container">',
  summary_html,
  '<h2 style="margin: 0.35rem 0;">Search</h2>',
  '  <div class="search-tip">Search matches across term names, definitions, and related terms. Use multiple words to narrow results (e.g., “reference point harvest”).</div>',
  '  <div style="margin: 0 0 1.25rem 0;">',
  '    <input ',
  '      type="text" ',
  '      id="vocab-search-input" ',
  '      placeholder="Search terms, definitions, or related concepts..." ',
  '      style="width: 100%; padding: 0.75rem; font-size: 1rem; border-radius: 0.25rem;"',
  '      autocomplete="off"',
  '    />',
  '    <div id="search-results-count" style="margin-top: 0.5rem; color: #6c757d; font-size: 0.9rem;"></div>',
  '  </div>',
  '  <div id="vocab-search-results"></div>',
  '</div>',
  '',
  '<script>',
  '(function() {',
  paste0('  const terms = ', terms_json, ';'),
  '  window.allTermsData = terms;',
  '  const searchInput = document.getElementById("vocab-search-input");',
  '  const resultsContainer = document.getElementById("vocab-search-results");',
  '  const countContainer = document.getElementById("search-results-count");',
  '  ',
  '  function normalizeText(text) {',
  '    return (text || "").toLowerCase().trim();',
  '  }',
  '  ',
  '  function searchTerms(query) {',
  '    if (!query) {',
  '      resultsContainer.innerHTML = "";',
  '      countContainer.textContent = "";',
  '      return;',
  '    }',
  '    ',
  '    const normalizedQuery = normalizeText(query);',
  '    const queryWords = normalizedQuery.split(/\\s+/).filter(w => w.length > 0);',
  '    ',
  '    const matches = terms.filter(term => {',
  '      const searchableText = normalizeText(',
  '        term.term_name + " " + ',
  '        term.definition + " " + ',
  '        term.related_terms',
  '      );',
  '      ',
  '      return queryWords.every(word => searchableText.includes(word));',
  '    });',
  '    ',
  '    const countText = matches.length === 0 ',
  '      ? "No results found" ',
  '      : "Found " + matches.length + " term" + (matches.length !== 1 ? "s" : "");',
  '    countContainer.textContent = countText;',
  '    ',
  '    if (matches.length === 0) {',
  '      resultsContainer.innerHTML = "<p style=\\"color: #6c757d; padding: 1rem;\\">No matching terms found. Try different keywords or browse by theme below.</p>";',
  '      return;',
  '    }',
  '    ',
  '    let html = "<div style=\\"display: grid; gap: 1rem;\\">";',
  '    matches.forEach(term => {',
  '      const uri = term.canonical_uri || "";',
  '      const sourceText = term.definition_source_text || "";',
  '      const sourceLink = term.definition_source_link || "";',
  '      let sourceHtml = "";',
  '      if (sourceText) {',
  '        sourceHtml = sourceText;',
  '        if (sourceLink) {',
  '          sourceHtml += "<br><a href=\\"" + sourceLink + "\\" target=\\"_blank\\" rel=\\"noopener\\" style=\\"font-size: 0.9rem; color: #446c8a;\\">Source</a>";',
  '        }',
  '      } else if (sourceLink) {',
  '        sourceHtml = "<a href=\\"" + sourceLink + "\\" target=\\"_blank\\" rel=\\"noopener\\" style=\\"font-size: 0.9rem; color: #446c8a;\\">" + sourceLink + "</a>";',
  '      }',
  '      ',
  '      const themeName = term.theme || "";',
  '      const termName = term.term_name || "";',
  '      const definition = term.definition || "No definition available";',
  '      ',
  '      html += "<div style=\\"border: 1px solid #dee2e6; border-radius: 0.25rem; padding: 1rem; background: white;\\">";',
  '      html += "<div style=\\"display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;\\">";',
  '      html += "<h3 style=\\"margin: 0; font-size: 1.1rem; color: #446c8a;\\">" + termName + "</h3>";',
  '      html += "<span style=\\"font-size: 0.85rem; color: #6c757d; background: #f8f9fa; padding: 0.25rem 0.5rem; border-radius: 0.25rem;\\">" + themeName + "</span>";',
  '      html += "</div>";',
  '      html += "<p style=\\"margin: 0.5rem 0; color: #495057;\\">" + definition + "</p>";',
  '      if (sourceHtml) {',
  '        html += "<p style=\\"margin: 0.5rem 0; font-size: 0.9rem; color: #6c757d; font-style: italic;\\">Source: " + sourceHtml + "</p>";',
  '      }',
  '      html += "<div style=\\"display: flex; gap: 1rem; margin-top: 0.75rem; font-size: 0.9rem;\\">";',
  '      html += "<div style=\\"flex: 1;\\"><strong>URI:</strong> <code style=\\"font-size: 0.85rem;\\">" + uri + "</code>";',
  '      html += "<button type=\\"button\\" class=\\"copy-uri-btn\\" data-uri=\\"" + uri + "\\" style=\\"margin-left: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.85rem; border: 1px solid #dee2e6; background: white; border-radius: 0.25rem; cursor: pointer;\\">Copy</button></div>";',
  '      html += "</div></div>";',
  '    });',
  '    html += "</div>";',
  '    resultsContainer.innerHTML = html;',
  '    ',
  '    document.querySelectorAll(".copy-uri-btn").forEach(btn => {',
  '      btn.addEventListener("click", function() {',
  '        const uri = this.getAttribute("data-uri");',
  '        navigator.clipboard.writeText(uri).then(() => {',
  '          const original = this.textContent;',
  '          this.textContent = "Copied!";',
  '          setTimeout(() => {',
  '            this.textContent = original;',
  '          }, 1500);',
  '        });',
  '      });',
  '    });',
  '  }',
  '  ',
  '  let searchTimeout;',
  '  searchInput.addEventListener("input", function() {',
  '    clearTimeout(searchTimeout);',
  '    const query = this.value;',
  '    searchTimeout = setTimeout(() => searchTerms(query), 300);',
  '  });',
  '  ',
  '  resultsContainer.innerHTML = "";',
  '})();',
  '</script>'
)

search_html <- paste(search_html_parts, collapse = "\n")
knitr::raw_html(search_html)
```

## Browse All Terms

```{r}
#| echo: false
#| warning: false
library(htmltools)
library(knitr)
library(htmlwidgets)

# Get project root directory (reuse from previous chunk if available, otherwise find it)
if (!exists("project_root")) {
  project_root <- if (Sys.getenv("QUARTO_PROJECT_DIR") != "") {
    Sys.getenv("QUARTO_PROJECT_DIR")
  } else {
    current <- getwd()
    while (current != dirname(current)) {
      if (file.exists(file.path(current, "_quarto.yml"))) {
        break
      }
      current <- dirname(current)
    }
    current
  }
}

# Load required R packages
library(readr)
library(jsonlite)
library(reactable)
library(htmltools)
library(htmlwidgets)
library(knitr)

# Load helper functions (if not already loaded)
if (!exists("load_dataset")) {
  helpers_path <- file.path(project_root, "reference_info/ontology/_partials/helpers.R")
  source(helpers_path)
}

# Load yaml package if not already loaded
if (!requireNamespace("yaml", quietly = TRUE)) {
  stop("Package 'yaml' is required. Please install it with: install.packages('yaml')")
}
if (!exists("yaml")) {
  library(yaml)
}

# Load themes and combine all term tables
themes_with_desc <- load_themes(project_root, include_desc = TRUE)

combined_terms <- list()
for (theme in themes_with_desc) {
  theme_id <- theme$id
  csv_path <- file.path(
    project_root,
    "data/ontology/release/artifacts/term-tables",
    paste0(theme_id, ".csv")
  )
  result <- load_dataset(csv_path)
  df <- result$data

  if (!is.null(df) && nrow(df) > 0) {
    df$theme <- theme$label
    df$theme_id <- theme_id
    combined_terms[[length(combined_terms) + 1]] <- df
  }
}

if (length(combined_terms) == 0) {
  tags$p("No term tables found. Run the ontology extraction workflow to generate term tables.")
} else {
  terms_df <- do.call(rbind, combined_terms)

  # Ensure required columns exist
  required_cols <- c(
    "theme", "theme_id", "term_name", "definition", "definition_source",
    "related_terms", "canonical_uri", "widoco_link",
    "definition_source_text", "definition_source_link"
  )
  for (col in required_cols) {
    if (!col %in% names(terms_df)) {
      terms_df[[col]] <- ""
    }
  }
  terms_df[is.na(terms_df)] <- ""

  # Theme choices for the filter UI
  theme_choices <- vapply(
    themes_with_desc,
    function(t) t$label,
    FUN.VALUE = character(1)
  )

  # Custom column definitions (reuse logic from helpers)
  theme_filter_method <- JS("
    function(rows, columnId, filterValue) {
      if (!filterValue || filterValue.length === 0) return rows;
      return rows.filter(function(row) {
        return filterValue.includes(row.values[columnId]);
      });
    }
  ")

  term_table <- reactable(
    terms_df,
    columns = list(
      theme = colDef(
        name = "Theme",
        minWidth = 140,
        filterMethod = theme_filter_method
      ),
      term_name = colDef(
        name = "Term Name",
        minWidth = 140,
        resizable = TRUE
      ),
      definition = colDef(
        name = "Definition",
        minWidth = 320,
        resizable = TRUE
      ),
      definition_source = colDef(
        name = "Definition Source",
        minWidth = 200,
        resizable = TRUE,
        html = TRUE,
        cell = function(value, index) {
          row <- terms_df[index, ]

          clean_value <- function(val) {
            if (is.null(val) || is.na(val) || val == "nan" || val == "none" || val == "") {
              return("")
            }
            return(as.character(val))
          }

          is_url_iri <- function(val) {
            val <- clean_value(val)
            if (val == "") return(FALSE)
            return(startsWith(val, "http://") || startsWith(val, "https://") ||
                     startsWith(val, "urn:") || startsWith(val, "doi:"))
          }

          make_link <- function(url) {
            HTML(paste0(
              '<a href="', htmlEscape(url, attribute = TRUE),
              '" target="_blank" rel="noopener" style="color: #446c8a;">',
              htmlEscape(url), '</a>'
            ))
          }

          source_link <- clean_value(row$definition_source_link)
          source_text <- clean_value(row$definition_source_text)
          source_raw <- clean_value(row$definition_source)

          if (is_url_iri(source_link)) {
            return(make_link(source_link))
          }
          if (is_url_iri(source_raw)) {
            return(make_link(source_raw))
          }

          if (source_text != "") {
            return(HTML(htmlEscape(source_text)))
          }
          if (source_raw != "") {
            return(HTML(htmlEscape(source_raw)))
          }

          HTML('<span class=\"coming-soon\">Not available</span>')
        }
      ),
      related_terms = colDef(
        name = "Related Terms",
        minWidth = 120,
        resizable = TRUE,
        html = TRUE,
        cell = function(value, index) {
          if (is.null(value) || is.na(value) || value == "" || value == "nan") {
            return(HTML('<span class=\"coming-soon\">None</span>'))
          }

          terms_str <- as.character(value)
          if (terms_str == "") {
            return(HTML('<span class=\"coming-soon\">None</span>'))
          }

          term_parts <- strsplit(terms_str, "; ")[[1]]
          links <- character(0)
          for (term_part in term_parts) {
            term_part <- trimws(term_part)
            if (term_part == "") next

            match <- regmatches(
              term_part,
              regexec("^(.+?)\\s+\\(([^)]+)\\)\\s+\\[(.+?)\\]$", term_part)
            )[[1]]

            if (length(match) >= 4) {
              term_name <- match[2]
              relation <- match[3]
              uri <- match[4]

              link_html <- paste0(
                '<a href=\"#\" ',
                'class=\"related-term-link\" ',
                'data-term-name=\"', htmlEscape(term_name, attribute = TRUE), '\" ',
                'data-term-uri=\"', htmlEscape(uri, attribute = TRUE), '\" ',
                'style=\"color: #446c8a; text-decoration: none; margin-right: 0.5rem; display: inline-block;\" ',
                'title=\"', htmlEscape(relation, attribute = TRUE), '\">',
                htmlEscape(term_name),
                '</a>'
              )
              links <- c(links, link_html)
            } else {
              links <- c(links, htmlEscape(term_part))
            }
          }

          if (length(links) == 0) {
            return(HTML('<span class=\"coming-soon\">None</span>'))
          }

          HTML(paste(links, collapse = " "))
        }
      ),
      canonical_uri = colDef(
        name = "Term ID",
        minWidth = 200,
        resizable = TRUE,
        html = TRUE,
        cell = function(value, index) {
          if (is.null(value) || is.na(value) || value == "" || value == "nan") {
            return(HTML('<span class=\"coming-soon\">Unavailable</span>'))
          }
          uri <- htmlEscape(value)
          HTML(paste0(
            '<a href="', htmlEscape(uri, attribute = TRUE),
            '" target="_blank" rel="noopener" style="color: #446c8a; font-family: monospace; font-size: 0.9em;">',
            uri, '</a>'
          ))
        }
      ),
      theme_id = colDef(show = FALSE),
      widoco_link = colDef(show = FALSE),
      definition_source_text = colDef(show = FALSE),
      definition_source_link = colDef(show = FALSE)
    ),
    defaultColDef = colDef(
      minWidth = 120,
      resizable = TRUE,
      filterable = FALSE
    ),
    resizable = TRUE,
    searchable = TRUE,
    filterable = FALSE,
    defaultPageSize = 25,
    showPageSizeOptions = TRUE,
    pageSizeOptions = c(10, 25, 50, 100),
    theme = reactableTheme(
      headerStyle = list(
        backgroundColor = "#f8f9fa",
        borderBottom = "1px solid #dee2e6"
      ),
      stripedColor = "#f8f9fa"
    ),
    elementId = "all-terms-table"
  )

  term_table <- htmlwidgets::onRender(
    term_table,
    HTML('
      function(el, x) {
        const style = document.createElement("style");
        style.textContent = `
          .coming-soon {
            color: #666;
            font-style: italic;
          }
        `;
        document.head.appendChild(style);
      }
    ')
  )

  # Build theme filter UI with multi-select checkboxes
  filter_controls <- tags$div(
    id = "theme-filter-container",
    style = "border: 1px solid #e9ecef; border-radius: 6px; padding: 0.75rem 1rem; background: #f8f9fa; margin-bottom: 0.75rem;",
    tags$div(
      style = "display: flex; justify-content: space-between; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;",
      tags$strong("Filter by theme"),
      tags$span(style = "font-size: 0.9rem; color: #6c757d;", "Use checkboxes to show one or more themes.")
    ),
    tags$div(
      style = "display: flex; flex-wrap: wrap; gap: 0.75rem;",
      lapply(theme_choices, function(label) {
        tags$label(
          style = "display: flex; align-items: center; gap: 0.35rem; font-size: 0.95rem; color: #495057;",
          tags$input(
            type = "checkbox",
            value = label,
            checked = "checked",
            style = "accent-color: #446c8a;"
          ),
          label
        )
      })
    )
  )

  filter_script <- tags$script(HTML("
    (function() {
      const container = document.getElementById('theme-filter-container');
      const tableId = 'all-terms-table';
      if (!container) return;

      const checkboxes = container.querySelectorAll('input[type=\"checkbox\"]');

      function applyThemeFilter() {
        const selected = Array.from(checkboxes)
          .filter(cb => cb.checked)
          .map(cb => cb.value);

        if (selected.length === 0 || selected.length === checkboxes.length) {
          Reactable.resetFilter(tableId, 'theme');
        } else {
          Reactable.setFilter(tableId, 'theme', selected);
        }
      }

      checkboxes.forEach(cb => cb.addEventListener('change', applyThemeFilter));

      if (window.Reactable && Reactable.onReady) {
        Reactable.onReady(tableId, applyThemeFilter);
      } else {
        document.addEventListener('DOMContentLoaded', applyThemeFilter);
        setTimeout(applyThemeFilter, 300);
      }
    })();
  "))

  browsable(
    tagList(
      filter_controls,
      term_table,
      filter_script
    )
  )
}
```

## About the Vocabulary Structure

Under the hood, the vocabulary is formatted in SKOS (Simple Knowledge Organization System), a W3C-recommended framework for representing controlled vocabularies and thesauri. By modeling terms and their relationships (broader, narrower, related), SKOS makes it easy to:

- Maintain consistent labels, definitions, and concept hierarchies.
- Share and integrate the vocabulary with other systems that understand RDF.

The vocabulary is intended to be a living document that evolves with the needs of the community. It is maintained by the Data Stewardship Unit (DSU) within the Fisheries and Assessment Data Section (FADS) in the Pacific Region of Fisheries and Oceans Canada (DFO).

The vocabulary is more than a simple glossary: it is a formally structured controlled vocabulary that uses the W3C-endorsed Simple Knowledge Organization System (SKOS), enabling machine-readable formats for integration into data systems, APIs, and web applications. For a deep-dive on the how and why of controlled vocabularies, see our guide: [Support Controlled Vocabularies](https://dfo-pacific-science.github.io/data-stewardship-unit/tutorials/support_controlled_vocabs.html).

## Contributing

File a GitHub Issue at https://github.com/dfo-pacific-science/data-stewardship-unit/issues

Or contact the Data Stewardship Unit.
